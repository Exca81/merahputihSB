<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boss Time Tracker - MERAHPUTIH</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* [CSS STYLE TETAP SAMA] */
        /* ... semua kode CSS sebelumnya tetap sama ... */
    </style>
</head>
<body>
    <!-- [HTML CONTENT TETAP SAMA] -->
    <!-- ... semua kode HTML sebelumnya tetap sama ... -->

    <script>
        // Admin credentials
        const ADMIN_CREDENTIALS = {
            username: "admin",
            password: "acumalaka2026"
        };
        
        // Days of week for display
        const DAYS_OF_WEEK = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const DAYS_SHORT = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        
        // Boss data structure
        let bossSchedule = [
            { 
                id: 1, 
                level: 88, 
                name: "Amentis", 
                type: "regular", 
                scheduleType: "interval", 
                nextSpawnTime: null,
                lastSpawnTime: null,
                respawnInterval: 2,
                spawnDays: null,
                notes: "",
                isActive: false,
                spawnOrder: 0
            },
            { 
                id: 2, 
                level: 75, 
                name: "Araneo", 
                type: "regular", 
                scheduleType: "interval",
                nextSpawnTime: null,
                lastSpawnTime: null,
                respawnInterval: 3,
                spawnDays: [1, 3, 5],
                notes: "Poison attacks",
                isActive: false,
                spawnOrder: 0
            },
            { 
                id: 3, 
                level: 100, 
                name: "Asta", 
                type: "world", 
                scheduleType: "weekly",
                nextSpawnTime: null,
                lastSpawnTime: null,
                respawnInterval: 0,
                spawnDays: [6],
                notes: "Weekend world boss - Sabtu jam 16:00",
                isActive: false,
                spawnOrder: 0
            },
            { 
                id: 4, 
                level: 150, 
                name: "Ancient Dragon", 
                type: "raid", 
                scheduleType: "interval",
                nextSpawnTime: null,
                lastSpawnTime: null,
                respawnInterval: 32,
                spawnDays: null,
                notes: "32h respawn time, drops legendary items",
                isActive: false,
                spawnOrder: 0
            }
        ];
        
        // Application state
        let isAdminLoggedIn = false;
        let currentBossIndex = 0;
        let countdownSeconds = 0;
        let activeBossId = null;
        
        // Alarm settings
        let alarmEnabled = true;
        let alarmMuted = false;
        let alarmTriggered = false;
        let alarmCooldown = false;
        const ALARM_THRESHOLD = 300;
        
        // Audio context for sound
        let audioContext;
        let alarmSound;
        
        // DOM Elements
        const adminLoginBtn = document.getElementById('adminLoginBtn');
        const adminLogoutBtn = document.getElementById('adminLogoutBtn');
        const adminNotes = document.getElementById('adminNotes');
        const currentBoss = document.getElementById('currentBoss');
        const countdownTimer = document.getElementById('countdownTimer');
        const bossSpawnTime = document.getElementById('bossSpawnTime');
        const indoTime = document.getElementById('indoTime');
        const phTime = document.getElementById('phTime');
        const bossScheduleTable = document.getElementById('bossSchedule');
        const refreshBtn = document.getElementById('refreshBtn');
        const countdownBtn = document.getElementById('countdownBtn');
        const alarmBtn = document.getElementById('alarmBtn');
        const timestampBtn = document.getElementById('timestampBtn');
        const editNotesBtn = document.getElementById('editNotesBtn');
        const editBossTimeBtn = document.getElementById('editBossTimeBtn');
        const editServerTimeBtn = document.getElementById('editServerTimeBtn');
        const editScheduleBtn = document.getElementById('editScheduleBtn');
        const addNewBossBtn = document.getElementById('addNewBossBtn');
        const toggleAlarmBtn = document.getElementById('toggleAlarmBtn');
        const testAlarmBtn = document.getElementById('testAlarmBtn');
        const muteAlarmBtn = document.getElementById('muteAlarmBtn');
        const alarmNotification = document.getElementById('alarmNotification');
        const alarmMessage = document.getElementById('alarmMessage');
        const closeAlarmBtn = document.getElementById('closeAlarmBtn');
        
        // Modal elements
        const loginModal = document.getElementById('loginModal');
        const addBossModal = document.getElementById('addBossModal');
        const intervalGroup = document.getElementById('intervalGroup');
        const intervalNote = document.getElementById('intervalNote');
        const respawnIntervalInput = document.getElementById('respawnInterval');
        const editBossIdInput = document.getElementById('editBossId');
        const saveBossBtn = document.getElementById('saveBossBtn');
        const modalTitle = document.querySelector('#addBossModal .modal-title');
        const bossTypeSelect = document.getElementById('bossType');
        
        // Initialize function
        function init() {
            loadFromLocalStorage();
            initializeAudio();
            calculateAllNextSpawnTimes();
            sortBossesBySpawnTime();
            updateActiveBoss();
            populateBossSchedule();
            updateTimes();
            setInterval(updateTimes, 1000);
            setInterval(checkBossSpawn, 1000);
            setInterval(checkAlarm, 1000);
            
            updateAlarmButtons();
            
            // Add event listener for day selection changes
            document.querySelectorAll('.day-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', updateFormBasedOnSchedule);
            });
            
            // Add event listener for boss type changes
            bossTypeSelect.addEventListener('change', updateFormBasedOnSchedule);
            
            // Initialize event listeners
            initEventListeners();
        }
        
        // Update form based on schedule type
        function updateFormBasedOnSchedule() {
            const selectedBossType = bossTypeSelect.value;
            const anyDaySelected = document.querySelectorAll('.day-checkbox:checked').length > 0;
            
            // Jika boss type adalah "weekly" atau ada hari yang dipilih
            if (selectedBossType === "weekly" || anyDaySelected) {
                intervalGroup.style.display = 'none';
                respawnIntervalInput.value = 0;
                respawnIntervalInput.required = false;
                intervalNote.innerHTML = '<strong>Weekly Schedule:</strong> Boss akan spawn pada hari yang dipilih setiap minggu pada jam yang sama.';
            } else {
                intervalGroup.style.display = 'block';
                respawnIntervalInput.value = respawnIntervalInput.value || 2;
                respawnIntervalInput.required = true;
                intervalNote.innerHTML = 'Untuk boss yang spawn setiap hari. Contoh: input 16:00 dengan interval 10h = next spawn 02:00';
            }
        }
        
        // Initialize all event listeners
        function initEventListeners() {
            // Admin login/logout
            adminLoginBtn.addEventListener('click', () => openModal(loginModal));
            adminLogoutBtn.addEventListener('click', logoutAdmin);
            
            // Alarm controls
            toggleAlarmBtn.addEventListener('click', function() {
                alarmEnabled = !alarmEnabled;
                updateAlarmButtons();
                saveToLocalStorage();
                showNotification(`Alarm ${alarmEnabled ? 'enabled' : 'disabled'}`);
            });
            
            testAlarmBtn.addEventListener('click', testAlarm);
            
            muteAlarmBtn.addEventListener('click', function() {
                alarmMuted = !alarmMuted;
                if (alarmMuted) {
                    stopAlarmSound();
                }
                updateAlarmButtons();
                saveToLocalStorage();
                showNotification(`Alarm ${alarmMuted ? 'muted' : 'unmuted'}`);
            });
            
            closeAlarmBtn.addEventListener('click', closeAlarm);
            
            alarmBtn.addEventListener('click', testAlarm);
            
            // Login form
            document.getElementById('loginForm').addEventListener('submit', function(e) {
                e.preventDefault();
                const username = document.getElementById('adminUsername').value;
                const password = document.getElementById('adminPassword').value;
                loginAdmin(username, password);
            });
            
            // Add new boss button
            addNewBossBtn.addEventListener('click', addNewBoss);
            editScheduleBtn.addEventListener('click', addNewBoss);
            
            // Add/Edit boss form
            document.getElementById('addBossForm').addEventListener('submit', function(e) {
                e.preventDefault();
                handleBossFormSubmit();
            });
            
            // Close modals
            document.getElementById('closeLoginModal').addEventListener('click', () => closeModal(loginModal));
            document.getElementById('closeAddBossModal').addEventListener('click', () => closeModal(addBossModal));
            document.getElementById('cancelLogin').addEventListener('click', () => closeModal(loginModal));
            document.getElementById('cancelAddBoss').addEventListener('click', () => closeModal(addBossModal));
            
            // Edit notes button
            editNotesBtn.addEventListener('click', function() {
                adminNotes.focus();
                showNotification('Notes editor activated');
            });
            
            // Save notes on change
            adminNotes.addEventListener('change', function() {
                saveToLocalStorage();
                showNotification('Notes saved');
            });
            
            // Original button event handlers
            refreshBtn.addEventListener('click', function() {
                calculateAllNextSpawnTimes();
                sortBossesBySpawnTime();
                updateActiveBoss();
                populateBossSchedule();
                showNotification('All boss data refreshed!');
            });
            
            countdownBtn.addEventListener('click', function() {
                const bossName = currentBoss.textContent;
                const timeLeft = countdownTimer.textContent;
                showNotification(`Next boss "${bossName}" spawns in ${timeLeft}`);
            });
            
            timestampBtn.addEventListener('click', function() {
                const now = new Date();
                const timestamp = now.toISOString();
                showNotification(`Current timestamp: ${timestamp}`);
                navigator.clipboard.writeText(timestamp);
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (e) => {
                if (e.target === loginModal) closeModal(loginModal);
                if (e.target === addBossModal) closeModal(addBossModal);
                if (e.target === alarmNotification) closeAlarm();
            });
            
            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                setTimeout(() => {
                    Notification.requestPermission();
                }, 2000);
            }
        }
        
        // Handle boss form submission - PERBAIKAN BESAR DI SINI
        function handleBossFormSubmit() {
            const level = parseInt(document.getElementById('bossLevel').value);
            const name = document.getElementById('bossName').value.trim();
            const type = document.getElementById('bossType').value;
            const hour = parseInt(document.getElementById('spawnHour').value) || 0;
            const minute = parseInt(document.getElementById('spawnMinute').value) || 0;
            const respawnInterval = parseInt(respawnIntervalInput.value) || 2;
            const notes = document.getElementById('bossNotes').value.trim();
            const bossId = editBossIdInput.value ? parseInt(editBossIdInput.value) : null;
            
            // Get selected days
            const selectedDays = [];
            document.querySelectorAll('.day-checkbox:checked').forEach(cb => {
                selectedDays.push(parseInt(cb.value));
            });
            
            // Validasi input
            if (!name) {
                showNotification('Boss name is required', 'error');
                return;
            }
            
            if (hour < 0 || hour > 23) {
                showNotification('Hour must be between 0 and 23', 'error');
                return;
            }
            
            if (minute < 0 || minute > 59) {
                showNotification('Minute must be between 0 and 59', 'error');
                return;
            }
            
            // Tentukan jadwal berdasarkan type dan hari yang dipilih
            let spawnDays = null;
            let finalInterval = respawnInterval;
            let scheduleType = "interval";
            
            // Jika boss type adalah weekly ATAU ada hari yang dipilih, maka jadwalnya weekly
            if (type === "weekly" || selectedDays.length > 0) {
                scheduleType = "weekly";
                finalInterval = 0; // Weekly tidak pakai interval
                spawnDays = selectedDays.length > 0 ? selectedDays : [0, 1, 2, 3, 4, 5, 6]; // Default semua hari jika tidak ada yang dipilih
                
                // Untuk weekly boss, pastikan ada minimal 1 hari yang dipilih
                if (selectedDays.length === 0 && type === "weekly") {
                    showNotification('For weekly boss, please select at least one day', 'error');
                    return;
                }
            } else {
                // Boss interval (setiap hari)
                scheduleType = "interval";
                spawnDays = null; // null berarti setiap hari
                
                // Validasi interval
                if (finalInterval < 1 || finalInterval > 168) {
                    showNotification('Respawn interval must be between 1 and 168 hours', 'error');
                    return;
                }
            }
            
            // Create LAST spawn time based on user input
            const now = new Date();
            let lastSpawn = new Date(now);
            lastSpawn.setHours(hour, minute, 0, 0);
            
            // If the input time is in the future today, adjust to yesterday
            if (lastSpawn > now) {
                lastSpawn.setDate(lastSpawn.getDate() - 1);
            }
            
            // Calculate next spawn based on schedule type
            let nextSpawn;
            
            if (scheduleType === "weekly") {
                // WEEKLY SCHEDULE - spawn pada hari tertentu setiap minggu
                nextSpawn = calculateNextWeeklySpawn(lastSpawn, spawnDays);
            } else {
                // INTERVAL SCHEDULE - spawn setiap X jam
                nextSpawn = new Date(lastSpawn.getTime() + finalInterval * 3600000);
                
                // Make sure next spawn is in the future
                while (nextSpawn <= now) {
                    nextSpawn.setTime(nextSpawn.getTime() + finalInterval * 3600000);
                }
            }
            
            if (bossId) {
                // UPDATE EXISTING BOSS
                const bossIndex = bossSchedule.findIndex(b => b.id === bossId);
                
                if (bossIndex !== -1) {
                    bossSchedule[bossIndex] = {
                        ...bossSchedule[bossIndex],
                        level,
                        name,
                        type,
                        scheduleType: scheduleType,
                        respawnInterval: finalInterval,
                        spawnDays: spawnDays,
                        notes,
                        lastSpawnTime: lastSpawn.toISOString(),
                        nextSpawnTime: nextSpawn.toISOString(),
                        isActive: false
                    };
                    
                    showNotification(`Boss ${name} updated successfully!`);
                }
            } else {
                // ADD NEW BOSS
                const newBoss = {
                    id: bossSchedule.length > 0 ? Math.max(...bossSchedule.map(b => b.id)) + 1 : 1,
                    level,
                    name,
                    type,
                    scheduleType: scheduleType,
                    respawnInterval: finalInterval,
                    spawnDays: spawnDays,
                    notes,
                    lastSpawnTime: lastSpawn.toISOString(),
                    nextSpawnTime: nextSpawn.toISOString(),
                    isActive: false,
                    spawnOrder: 0
                };
                
                bossSchedule.push(newBoss);
                showNotification(`New boss ${name} added to schedule!`);
            }
            
            // Recalculate all spawn times and sort
            calculateAllNextSpawnTimes();
            sortBossesBySpawnTime();
            updateActiveBoss();
            populateBossSchedule();
            closeModal(addBossModal);
            saveToLocalStorage();
            
            // Reset form
            editBossIdInput.value = '';
            modalTitle.innerHTML = '<i class="fas fa-dragon"></i> Add New Field Boss';
            saveBossBtn.textContent = 'Add Boss';
        }
        
        // Calculate next weekly spawn
        function calculateNextWeeklySpawn(lastSpawn, spawnDays) {
            const now = new Date();
            let nextSpawn = new Date(lastSpawn);
            
            // Cari hari berikutnya yang termasuk dalam spawnDays
            while (true) {
                nextSpawn.setDate(nextSpawn.getDate() + 1);
                
                // Cek apakah hari ini termasuk dalam spawnDays
                const dayOfWeek = nextSpawn.getDay();
                if (spawnDays.includes(dayOfWeek) && nextSpawn > now) {
                    break;
                }
            }
            
            return nextSpawn;
        }
        
        // Initialize audio context for alarm sound
        function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                createAlarmSound();
            } catch (e) {
                console.warn('Web Audio API not supported, alarm sound disabled');
                alarmMuted = true;
                updateAlarmButtons();
            }
        }
        
        // Create alarm sound using Web Audio API
        function createAlarmSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.value = 0.25;
            
            alarmSound = {
                oscillator: oscillator,
                gainNode: gainNode,
                playing: false
            };
        }
        
        // Play alarm sound
        function playAlarmSound() {
            if (!alarmSound || alarmMuted || !alarmEnabled) return;
            
            try {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                alarmSound.oscillator.start();
                alarmSound.playing = true;
                
                const now = audioContext.currentTime;
                const beepDuration = 0.3;
                const pauseDuration = 0.2;
                
                // Beep 1
                alarmSound.gainNode.gain.setValueAtTime(0, now);
                alarmSound.gainNode.gain.linearRampToValueAtTime(0.25, now + 0.05);
                alarmSound.gainNode.gain.setValueAtTime(0.25, now + beepDuration - 0.05);
                alarmSound.gainNode.gain.linearRampToValueAtTime(0, now + beepDuration);
                
                // Beep 2
                alarmSound.gainNode.gain.setValueAtTime(0, now + beepDuration + pauseDuration);
                alarmSound.gainNode.gain.linearRampToValueAtTime(0.25, now + beepDuration + pauseDuration + 0.05);
                alarmSound.gainNode.gain.setValueAtTime(0.25, now + 2*beepDuration + pauseDuration - 0.05);
                alarmSound.gainNode.gain.linearRampToValueAtTime(0, now + 2*beepDuration + pauseDuration);
                
                // Beep 3
                alarmSound.gainNode.gain.setValueAtTime(0, now + 2*beepDuration + 2*pauseDuration);
                alarmSound.gainNode.gain.linearRampToValueAtTime(0.25, now + 2*beepDuration + 2*pauseDuration + 0.05);
                alarmSound.gainNode.gain.setValueAtTime(0.25, now + 3*beepDuration + 2*pauseDuration - 0.05);
                alarmSound.gainNode.gain.linearRampToValueAtTime(0, now + 3*beepDuration + 2*pauseDuration);
                
                setTimeout(() => {
                    if (alarmSound && alarmSound.playing) {
                        alarmSound.oscillator.stop();
                        alarmSound.playing = false;
                        createAlarmSound();
                    }
                }, 2000);
                
            } catch (e) {
                console.warn('Failed to play alarm sound:', e);
            }
        }
        
        // Stop alarm sound
        function stopAlarmSound() {
            if (alarmSound && alarmSound.playing) {
                try {
                    alarmSound.oscillator.stop();
                    alarmSound.playing = false;
                    createAlarmSound();
                } catch (e) {
                    console.warn('Failed to stop alarm sound:', e);
                }
            }
        }
        
        // Test alarm sound
        function testAlarm() {
            if (alarmMuted) {
                showNotification('Alarm is muted. Unmute to test.', 'error');
                return;
            }
            
            playAlarmSound();
            showNotification('Testing alarm sound...');
        }
        
        // Update alarm button states
        function updateAlarmButtons() {
            toggleAlarmBtn.innerHTML = alarmEnabled ? 
                '<i class="fas fa-bell"></i> Alarm: ON' : 
                '<i class="fas fa-bell-slash"></i> Alarm: OFF';
            toggleAlarmBtn.classList.toggle('active', alarmEnabled);
            
            muteAlarmBtn.innerHTML = alarmMuted ? 
                '<i class="fas fa-volume-up"></i> Unmute' : 
                '<i class="fas fa-volume-mute"></i> Mute';
            muteAlarmBtn.classList.toggle('muted', alarmMuted);
        }
        
        // Check for alarm condition
        function checkAlarm() {
            if (!alarmEnabled || alarmCooldown) return;
            
            const activeBoss = bossSchedule.find(boss => boss.isActive);
            if (!activeBoss || !activeBoss.nextSpawnTime) return;
            
            const now = new Date();
            const spawnTime = new Date(activeBoss.nextSpawnTime);
            const timeDiff = Math.floor((spawnTime.getTime() - now.getTime()) / 1000);
            
            if (timeDiff <= ALARM_THRESHOLD && timeDiff > 0) {
                if (!alarmTriggered) {
                    triggerAlarm(activeBoss, timeDiff);
                }
            } else if (timeDiff > ALARM_THRESHOLD) {
                alarmTriggered = false;
                countdownTimer.classList.remove('alarm');
            }
        }
        
        // Trigger the alarm
        function triggerAlarm(boss, timeDiff) {
            alarmTriggered = true;
            
            countdownTimer.classList.add('alarm');
            
            playAlarmSound();
            
            const minutes = Math.floor(timeDiff / 60);
            const seconds = timeDiff % 60;
            alarmMessage.textContent = `${boss.name} will spawn in ${minutes}m ${seconds}s!`;
            alarmNotification.style.display = 'block';
            
            alarmCooldown = true;
            setTimeout(() => {
                alarmCooldown = false;
            }, 10000);
            
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(`BOSS ALERT: ${boss.name}`, {
                    body: `Will spawn in ${minutes} minutes!`,
                    icon: 'https://cdn-icons-png.flaticon.com/512/1995/1995515.png'
                });
            }
        }
        
        // Close alarm notification
        function closeAlarm() {
            alarmNotification.style.display = 'none';
            countdownTimer.classList.remove('alarm');
            stopAlarmSound();
        }
        
        // Load data from localStorage
        function loadFromLocalStorage() {
            const savedSchedule = localStorage.getItem('acumalakaBossSchedule');
            if (savedSchedule) {
                try {
                    bossSchedule = JSON.parse(savedSchedule);
                } catch (e) {
                    console.error('Error loading schedule:', e);
                }
            }
            
            const savedNotes = localStorage.getItem('acumalakaGuildNotes');
            if (savedNotes) {
                adminNotes.value = savedNotes;
            }
            
            const savedAlarmEnabled = localStorage.getItem('acumalakaAlarmEnabled');
            if (savedAlarmEnabled !== null) {
                alarmEnabled = savedAlarmEnabled === 'true';
            }
            
            const savedAlarmMuted = localStorage.getItem('acumalakaAlarmMuted');
            if (savedAlarmMuted !== null) {
                alarmMuted = savedAlarmMuted === 'true';
            }
        }
        
        // Save data to localStorage
        function saveToLocalStorage() {
            localStorage.setItem('acumalakaBossSchedule', JSON.stringify(bossSchedule));
            localStorage.setItem('acumalakaGuildNotes', adminNotes.value);
            localStorage.setItem('acumalakaAlarmEnabled', alarmEnabled);
            localStorage.setItem('acumalakaAlarmMuted', alarmMuted);
        }
        
        // Calculate next spawn time
        function calculateAllNextSpawnTimes() {
            const now = new Date();
            
            bossSchedule.forEach(boss => {
                if (!boss.lastSpawnTime) {
                    // Set default last spawn time
                    boss.lastSpawnTime = new Date(now.getTime() - 3600000).toISOString(); // 1 jam yang lalu
                }
                
                const lastSpawn = new Date(boss.lastSpawnTime);
                let nextSpawn;
                
                if (boss.scheduleType === "weekly" && boss.spawnDays && boss.spawnDays.length > 0) {
                    nextSpawn = calculateNextWeeklySpawn(lastSpawn, boss.spawnDays);
                } else {
                    // Interval schedule
                    let interval = boss.respawnInterval > 0 ? boss.respawnInterval : 2; // Default 2 jam
                    nextSpawn = new Date(lastSpawn.getTime() + interval * 3600000);
                    
                    // Make sure next spawn is in the future
                    while (nextSpawn <= now) {
                        nextSpawn.setTime(nextSpawn.getTime() + interval * 3600000);
                    }
                }
                
                boss.nextSpawnTime = nextSpawn.toISOString();
                boss.isActive = false;
            });
            
            saveToLocalStorage();
        }
        
        // Sort bosses by spawn time
        function sortBossesBySpawnTime() {
            bossSchedule.sort((a, b) => {
                if (!a.nextSpawnTime && !b.nextSpawnTime) return 0;
                if (!a.nextSpawnTime) return 1;
                if (!b.nextSpawnTime) return -1;
                
                const timeA = new Date(a.nextSpawnTime).getTime();
                const timeB = new Date(b.nextSpawnTime).getTime();
                return timeA - timeB;
            });
            
            bossSchedule.forEach((boss, index) => {
                boss.spawnOrder = index + 1;
            });
        }
        
        // Update which boss is active
        function updateActiveBoss() {
            const now = new Date();
            let closestBoss = null;
            let closestTime = Infinity;
            let closestIndex = -1;
            
            bossSchedule.forEach((boss, index) => {
                if (boss.nextSpawnTime) {
                    const spawnTime = new Date(boss.nextSpawnTime);
                    const timeDiff = spawnTime.getTime() - now.getTime();
                    
                    if (timeDiff > 0 && timeDiff < closestTime) {
                        closestTime = timeDiff;
                        closestBoss = boss;
                        closestIndex = index;
                    }
                }
            });
            
            if (closestBoss) {
                currentBossIndex = closestIndex;
                activeBossId = closestBoss.id;
                currentBoss.textContent = closestBoss.name;
                countdownSeconds = Math.floor(closestTime / 1000);
                
                bossSchedule.forEach(boss => {
                    boss.isActive = (boss.id === closestBoss.id);
                });
                
                const spawnTime = new Date(closestBoss.nextSpawnTime);
                const timeStr = spawnTime.toLocaleTimeString('en-US', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                let dayInfo = '';
                if (closestBoss.spawnDays && closestBoss.spawnDays.length > 0) {
                    const days = closestBoss.spawnDays.map(d => DAYS_SHORT[d]).join(', ');
                    dayInfo = ` (${days})`;
                }
                
                bossSpawnTime.textContent = 
                    `${timeStr} | ${DAYS_OF_WEEK[spawnTime.getDay()]}${dayInfo}`;
            }
        }
        
        // Check if any boss has spawned
        function checkBossSpawn() {
            const now = new Date();
            let updated = false;
            
            bossSchedule.forEach(boss => {
                if (boss.nextSpawnTime && new Date(boss.nextSpawnTime) <= now) {
                    boss.lastSpawnTime = boss.nextSpawnTime;
                    
                    let nextSpawn;
                    const lastSpawn = new Date(boss.lastSpawnTime);
                    
                    if (boss.scheduleType === "weekly" && boss.spawnDays && boss.spawnDays.length > 0) {
                        nextSpawn = calculateNextWeeklySpawn(lastSpawn, boss.spawnDays);
                    } else {
                        let interval = boss.respawnInterval > 0 ? boss.respawnInterval : 2;
                        nextSpawn = new Date(lastSpawn.getTime() + interval * 3600000);
                        
                        // Make sure next spawn is in the future
                        while (nextSpawn <= now) {
                            nextSpawn.setTime(nextSpawn.getTime() + interval * 3600000);
                        }
                    }
                    
                    boss.nextSpawnTime = nextSpawn.toISOString();
                    updated = true;
                    
                    if (boss.isActive) {
                        showNotification(`ðŸŽ‰ ${boss.name} has spawned!`);
                        alarmTriggered = false;
                        countdownTimer.classList.remove('alarm');
                    }
                }
            });
            
            if (updated) {
                sortBossesBySpawnTime();
                updateActiveBoss();
                populateBossSchedule();
                saveToLocalStorage();
            }
        }
        
        // Initialize boss schedule table
        function populateBossSchedule() {
            bossScheduleTable.innerHTML = '';
            const now = new Date();
            const currentDay = now.getDay();
            
            bossSchedule.forEach(boss => {
                const nextSpawn = boss.nextSpawnTime ? new Date(boss.nextSpawnTime) : null;
                const lastSpawn = boss.lastSpawnTime ? new Date(boss.lastSpawnTime) : null;
                
                let scheduleTypeHTML = '';
                let lastSpawnHTML = '';
                let nextSpawnHTML = '';
                let rowClass = '';
                
                if (boss.spawnDays && boss.spawnDays.length > 0 && !boss.spawnDays.includes(currentDay)) {
                    rowClass = 'inactive-day';
                }
                
                // Schedule type display
                if (boss.scheduleType === "weekly" && boss.spawnDays && boss.spawnDays.length > 0) {
                    const days = boss.spawnDays.map(d => DAYS_SHORT[d]).join(', ');
                    scheduleTypeHTML = `<span class="fixed-schedule">Weekly: ${days}</span>`;
                } else if (boss.respawnInterval > 0) {
                    scheduleTypeHTML = `<span class="interval-schedule">Every ${boss.respawnInterval}h</span>`;
                }
                
                // Last spawn display
                if (lastSpawn) {
                    const timeStr = lastSpawn.toLocaleTimeString('en-US', { 
                        hour12: false, 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    const dateStr = lastSpawn.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                    lastSpawnHTML = `
                        <div>${timeStr}</div>
                        <div class="last-spawn-time">${dateStr}</div>
                    `;
                } else {
                    lastSpawnHTML = `<span style="color:var(--gray); font-size:0.9rem;">No record</span>`;
                }
                
                // Next spawn display
                if (nextSpawn) {
                    const timeDiff = nextSpawn.getTime() - now.getTime();
                    const daysLeft = Math.floor(timeDiff / (3600000 * 24));
                    const hoursLeft = Math.floor((timeDiff % (3600000 * 24)) / 3600000);
                    const minutesLeft = Math.floor((timeDiff % 3600000) / 60000);
                    
                    let timeLeftText = '';
                    if (daysLeft > 0) {
                        timeLeftText = `${daysLeft}d ${hoursLeft}h left`;
                    } else if (hoursLeft > 0) {
                        timeLeftText = `${hoursLeft}h ${minutesLeft}m left`;
                    } else {
                        timeLeftText = `${minutesLeft}m left`;
                    }
                    
                    const alarmIndicator = timeDiff <= ALARM_THRESHOLD && timeDiff > 0 ? 
                        '<span class="alarm-indicator">ALARM!</span>' : '';
                    
                    const nextSpawnTimeStr = nextSpawn.toLocaleTimeString('en-US', { 
                        hour12: false, 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    nextSpawnHTML = `
                        <div class="next-spawn-time">${nextSpawnTimeStr} ${alarmIndicator}</div>
                        <div class="last-spawn-time">${timeLeftText}</div>
                    `;
                } else {
                    nextSpawnHTML = `<span style="color:var(--gray); font-size:0.9rem;">Schedule not set</span>`;
                }
                
                const row = document.createElement('tr');
                if (boss.isActive) {
                    row.className = 'active-boss';
                } else if (rowClass) {
                    row.className = rowClass;
                }
                
                row.innerHTML = `
                    <td><span class="spawn-order">${boss.spawnOrder}</span></td>
                    <td><span class="boss-level">${boss.level}</span></td>
                    <td>
                        <strong>${boss.name}</strong>
                        ${boss.isActive ? '<span class="active-indicator">NEXT</span>' : ''}
                        ${boss.spawnDays && boss.spawnDays.length > 0 && !boss.spawnDays.includes(currentDay) ? 
                          '<span class="day-off-badge">NOT TODAY</span>' : ''}
                    </td>
                    <td>${scheduleTypeHTML}</td>
                    <td>${lastSpawnHTML}</td>
                    <td>${nextSpawnHTML}</td>
                    <td class="admin-only-block" style="display: ${isAdminLoggedIn ? 'table-cell' : 'none'};">
                        <button class="action-btn edit-boss-btn" data-id="${boss.id}" title="Edit Boss">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="action-btn delete-boss-btn" data-id="${boss.id}" title="Delete Boss">
                            <i class="fas fa-trash"></i>
                        </button>
                    </td>
                `;
                bossScheduleTable.appendChild(row);
            });
            
            // Add event listeners to action buttons
            setTimeout(() => {
                document.querySelectorAll('.edit-boss-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const bossId = parseInt(this.getAttribute('data-id'));
                        editBoss(bossId);
                    });
                });
                
                document.querySelectorAll('.delete-boss-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const bossId = parseInt(this.getAttribute('data-id'));
                        deleteBoss(bossId);
                    });
                });
            }, 0);
        }
        
        // Update time displays
        function updateTimes() {
            const now = new Date();
            
            // INDO TIME (UTC+7)
            const indoTimeObj = new Date(now.getTime() + (7 * 60 * 60 * 1000));
            const indoTimeStr = indoTimeObj.toISOString().substr(11, 8);
            indoTime.textContent = indoTimeStr;
            
            // PH TIME (UTC+8)
            const phTimeObj = new Date(now.getTime() + (8 * 60 * 60 * 1000));
            const phTimeStr = phTimeObj.toISOString().substr(11, 8);
            phTime.textContent = phTimeStr;
            
            updateCountdown();
        }
        
        // Update countdown timer
        function updateCountdown() {
            countdownSeconds--;
            
            if (countdownSeconds < 0) {
                countdownSeconds = 0;
            }
            
            const days = Math.floor(countdownSeconds / (3600 * 24));
            const hours = Math.floor((countdownSeconds % (3600 * 24)) / 3600);
            const minutes = Math.floor((countdownSeconds % 3600) / 60);
            const seconds = countdownSeconds % 60;
            
            let formattedTime = '';
            if (days > 0) {
                formattedTime = 
                    days.toString().padStart(2, '0') + 'd ' +
                    hours.toString().padStart(2, '0') + ':' +
                    minutes.toString().padStart(2, '0') + ':' +
                    seconds.toString().padStart(2, '0');
            } else if (hours > 0) {
                formattedTime = 
                    hours.toString().padStart(2, '0') + ':' +
                    minutes.toString().padStart(2, '0') + ':' +
                    seconds.toString().padStart(2, '0');
            } else {
                formattedTime = 
                    minutes.toString().padStart(2, '0') + ':' +
                    seconds.toString().padStart(2, '0');
            }
            
            countdownTimer.textContent = formattedTime;
            
            if (countdownSeconds <= ALARM_THRESHOLD && countdownSeconds > 0) {
                countdownTimer.style.color = '#ff0000';
                countdownTimer.style.textShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
            } else if (countdownSeconds < 300) {
                countdownTimer.style.color = '#dc2626';
                countdownTimer.style.textShadow = '0 0 10px rgba(220, 38, 38, 0.5)';
            } else {
                countdownTimer.style.color = '#dc2626';
                countdownTimer.style.textShadow = '0 0 10px rgba(220, 38, 38, 0.2)';
            }
        }
        
        // Admin login/logout functions
        function loginAdmin(username, password) {
            if (username === ADMIN_CREDENTIALS.username && password === ADMIN_CREDENTIALS.password) {
                isAdminLoggedIn = true;
                document.body.classList.add('admin-logged-in');
                adminLoginBtn.style.display = 'none';
                adminLogoutBtn.style.display = 'flex';
                adminNotes.readOnly = false;
                
                document.querySelectorAll('.admin-only').forEach(el => {
                    el.style.display = 'inline-flex';
                });
                document.querySelectorAll('.admin-only-block').forEach(el => {
                    el.style.display = 'block';
                });
                document.querySelectorAll('td.admin-only-block').forEach(el => {
                    el.style.display = 'table-cell';
                });
                
                showNotification('Admin login successful!');
                closeModal(loginModal);
                return true;
            } else {
                showNotification('Invalid username or password', 'error');
                return false;
            }
        }
        
        function logoutAdmin() {
            isAdminLoggedIn = false;
            document.body.classList.remove('admin-logged-in');
            adminLoginBtn.style.display = 'flex';
            adminLogoutBtn.style.display = 'none';
            adminNotes.readOnly = true;
            
            document.querySelectorAll('.admin-only').forEach(el => {
                el.style.display = 'none';
            });
            document.querySelectorAll('.admin-only-block').forEach(el => {
                el.style.display = 'none';
            });
            document.querySelectorAll('td.admin-only-block').forEach(el => {
                el.style.display = 'none';
            });
            
            showNotification('Admin logged out');
        }
        
        // Modal functions
        function openModal(modal) {
            modal.style.display = 'flex';
        }
        
        function closeModal(modal) {
            modal.style.display = 'none';
        }
        
        // Add new boss
        function addNewBoss() {
            document.getElementById('addBossForm').reset();
            
            document.getElementById('bossLevel').value = '';
            document.getElementById('bossName').value = '';
            respawnIntervalInput.value = 2;
            editBossIdInput.value = '';
            
            const now = new Date();
            document.getElementById('spawnHour').value = now.getHours();
            document.getElementById('spawnMinute').value = now.getMinutes();
            
            document.querySelectorAll('.day-checkbox').forEach(cb => {
                cb.checked = false;
            });
            
            // Reset form visibility
            updateFormBasedOnSchedule();
            
            modalTitle.innerHTML = '<i class="fas fa-dragon"></i> Add New Field Boss';
            saveBossBtn.textContent = 'Add Boss';
            
            openModal(addBossModal);
        }
        
        // Edit boss function
        function editBoss(bossId) {
            const boss = bossSchedule.find(b => b.id === bossId);
            if (!boss) return;
            
            document.getElementById('addBossForm').reset();
            
            // Set form values
            document.getElementById('bossLevel').value = boss.level;
            document.getElementById('bossName').value = boss.name;
            document.getElementById('bossType').value = boss.type;
            respawnIntervalInput.value = boss.respawnInterval || 2;
            document.getElementById('bossNotes').value = boss.notes || '';
            editBossIdInput.value = boss.id;
            
            // Show LAST spawn time
            if (boss.lastSpawnTime) {
                const lastSpawn = new Date(boss.lastSpawnTime);
                document.getElementById('spawnHour').value = lastSpawn.getHours();
                document.getElementById('spawnMinute').value = lastSpawn.getMinutes();
            } else {
                const now = new Date();
                document.getElementById('spawnHour').value = now.getHours();
                document.getElementById('spawnMinute').value = now.getMinutes();
            }
            
            // Fill day checkboxes
            if (boss.spawnDays) {
                document.querySelectorAll('.day-checkbox').forEach(cb => {
                    cb.checked = boss.spawnDays.includes(parseInt(cb.value));
                });
            } else {
                document.querySelectorAll('.day-checkbox').forEach(cb => {
                    cb.checked = false;
                });
            }
            
            // Update form visibility based on boss type and selected days
            updateFormBasedOnSchedule();
            
            modalTitle.innerHTML = '<i class="fas fa-edit"></i> Edit Field Boss';
            saveBossBtn.textContent = 'Update Boss';
            
            openModal(addBossModal);
        }
        
        // Delete boss function
        function deleteBoss(bossId) {
            if (confirm('Are you sure you want to delete this boss from the schedule?')) {
                bossSchedule = bossSchedule.filter(b => b.id !== bossId);
                calculateAllNextSpawnTimes();
                sortBossesBySpawnTime();
                updateActiveBoss();
                populateBossSchedule();
                saveToLocalStorage();
                showNotification('Boss deleted from schedule');
            }
        }
        
        // Show notification
        function showNotification(message, type = 'success') {
            const existingNotification = document.querySelector('.notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            const bgColor = type === 'error' ? '#dc2626' : '#10b981';
            const textColor = '#ffffff';
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: ${textColor};
                padding: 15px 25px;
                border-radius: 10px;
                z-index: 1000;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
                animation: slideIn 0.3s ease-out;
                font-weight: 600;
                border: 2px solid ${type === 'error' ? '#991b1b' : '#059669'};
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Add CSS for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Initialize the application
        init();
    </script>
</body>
</html>
